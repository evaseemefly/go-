## 代码说明

本代码为第二章 快速开始对应的相关代码  
此处做了一些记录

### 项目目录结构

<pre><code>
├── sample                               <=
│ ├── data                           <= 
│ │  ├── form_static                    <=  统计页面的主文件夹

│ ├── matchers                            <= 
│ ├── search                            <= 业务逻辑都在search包中
│ ├── main.go                            <= 程序入口文件，包名称为main，且拥有main函数
</code></pre>

每个可执行的 go 程序都有两个特征：

1. 名为 main 的函数
2. main.go 的包名为 main  
   注意 `main` 函数必须保存在 `main` 的包中；  
   go 中每一个.go 文件都属于一个包；  
   可以把`包名称`类比为`命名空间`
   注意每个`.go` 的代码文件里的`init`函数都会在 main 函数执行前调用

### 部分语法知识点的汇总

map 是一种特殊的数据结构：一种类似 k-v 的 键值对（可以理解为字典）  
可以理解为 `字典`

变量的零值  
在 go 中所有的变量都被初始化为其零值

| 类型       | 零值     |
| ---------- | -------- |
| 数值类型   | 0        |
| 字符串类型 | 空字符串 |
| 布尔       | false    |
| 指针       | nil      |

### 3 打包和工具链

#### 3.1 包

例如 http 的目录结构

<pre><code>.
├── 
├── net/http/
│   ├── cgi/
│   ├── cookiejar/
│   │   ├── testdata
│   │   │   ├── merlin
│   │   │   │   └── Owner: maojian,yuanmin
│   ├── fcgi/
│   ├── httptest/
│   ├── httputil/
│   ├── pprof/
│   ├── testdata/
</code></pre>

给包的名称的惯例是使用包所在的目录的名字，例如本示例中的包名称为 `net/http`  
http 目录下的所有文件都属于`http`包  
给包起名称应该使用 _简洁、全小写的_ 的名称

main 包中的 main 函数为执行文件的入口

#### 3.2 导入

习惯上将 import 语句包装在一个导入块中

例如
<code><pre>
import{
"fmt"
"strings"
}
</code></pre>

1. 远程导入
   例如：  
    <code><pre>
   import "github.com/spf13/viper"
   </code></pre>
   以上是一个 url 路径，会将包的源码保存在 gopath 指向路径里与 url 匹配的目录里

2. 命名导入
   导入多个包具有相同名字时，在 import 语句给出的包路径的左侧定义一个名字，将导入的包命名为新的名字
   <code><pre>
   import{
   myfmt "mylib/fmt"
   }
   </code></pre>

3. inti 函数  
   每个包可包含多个`init`函数，会在 main 函数之前执行

#### 3.4 常用工具

| 命令              | 描述     |
| ----------------- | -------- |
| go fmt 文件或包名 | 格式化   |
| go doc            | 打印文档 |

### 4 数组、切片和映射

三种类型的区别

#### 4.1 数组

数组是一个`长度固定`的数据类型，数组占用的内存是连续分配的

##### 4.1.2 声明和初始化

声明一个数组:  
方式 1：

```
var array [5] int
```

数组一旦声明，数组里存储的`数据类型`和`数组长度`就都`不能改变`了

方式 2：数组的`字面量表示法`

```
 array:=[5] int {10,20,30,40,50}
```

方式 3：go 自动计算声明数组的长度——使用`...`

```go
arrary:=[...] int{10,20,30}
```

方式 4 ：声明数组并指定特定元素的值

```go
array:=[5] int{1:10,2:20}
```

##### 4.1.3 使用数组

数组的内存布局是`连续的`，所以数组是效率很高的数据结构

```go
array:=[5] int {10,20,30,40,50}

array[2]=35
```

访问指针数组的元素

```go
array:=[5] *int{0:new(int),1:new(int)}

*array[0]=10
*array[1]=20
```

| 0                  | 1   | 2   | 3   | 4   |
| ------------------ | --- | --- | --- | --- |
| 地址指向整型的指针 |
| 10                 | 20  |

1. 只有同样类型（和长度）的一个数组赋值给另外一个数组
2. 编译器会组织类型不同的数组相互赋值
3. 把一个指针赋值给另一个

```go
var array1 [3] *string

array2:=[3] *string(new(string),new(string),new(string)
)

*array2[0]="red"
*array2[1]="blue"
*array2[2]="green"

// 将 array2 复制给 array1
array1=array2
```

##### 4.1.4 多维数组

##### 4.1.5 在函数间传递数组

在函数间传递数组是一个开销很大的操作  
因为在函数之前传递变量时，总是以 _值_ 的方式传递的。  
如果这个变量是一个数组，都会完整复制，并传递给函数  
对于需要处理一个较大的数组时，可以使用数组的指针

```go
// 8MB的数组
var array [1e6]int

// 将数组的地址传递给函数foo
foo(&array)

// 函数foo接收一个指向100w个整型值的数组的指针
func foo(array *[1e6]int){

}
```

#### 4.2 切片

切片可以按需自动增长和缩小。  
切片的动态增长是通过内置函数`append`来实现的  
切片的底层内存也是在`连续块中分配的`

##### 4.2.1 内部实现

切片的定义  
| 0 | 1 | 2  
| --- | --- | ---
| 指向底层数组的指针 |切片的长度|切片的容量

##### 4.2.2 创建和初始化

1. make 和切片字面量

- 使用 make 的方式创建切片

```go
slice:=make([]int,3,3)
```

不允许创建容量小于长度的切片

- 使用字面量的方式声明切片

```go
slice:=[]string{"red","blue","green"}

slice:=[]int{1,2,3}
```

注意在[]若指定了值，则创建的是数组而不是切片

```go
// 整型数组
array:=[3] int{10,20,30}

// 整型切片
slice:=[] int{1,2,3}
```

2. nil 和空切片  
   在声明时不做任何初始化，就会创建一个 nil 切片

```go
// 创建nil整型切片
var slice []int

slice :=make([]int,0)
```

##### 4.2.3 使用切片
